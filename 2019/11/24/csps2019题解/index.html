<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="zty的博客，主要更新oi相关，欢迎大家来玩。"><title>csps2019题解 | Blog of zty</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.1"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">csps2019题解</h1><a id="logo" href="/.">Blog of zty</a><p class="description">focus on coding</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">csps2019题解</h1><div class="post-meta">Nov 24, 2019<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h1 id="Day1-T1-格雷码"><a href="#Day1-T1-格雷码" class="headerlink" title="Day1 T1 格雷码"></a>Day1 T1 格雷码</h1><h3 id="前置知识-语法-模拟"><a href="#前置知识-语法-模拟" class="headerlink" title="前置知识: 语法, 模拟"></a>前置知识: 语法, 模拟</h3><p>$n$位格雷码有$n^2$个 , 分成第$k$个在左右哪边讨论即可<br>注意格雷码构造的时候有翻转操作<br>最大的坑点是 unsigned long long, 1ull, k不能加1</p>
<h3 id="code"><a href="#code" class="headerlink" title="code:"></a>code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> i, a[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, ull k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    ull len = <span class="number">1u</span>ll &lt;&lt; (n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(k &gt;= len) a[++i] = <span class="number">1</span>, solve(n - <span class="number">1</span>, len - k - <span class="number">1u</span>ll + len);</span><br><span class="line">    <span class="keyword">else</span> a[++i] = <span class="number">0</span>, solve(n - <span class="number">1</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ull k; <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %llu"</span>, &amp;n, &amp;k);</span><br><span class="line">    solve(n, k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, a[j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Day1-T2-括号树"><a href="#Day1-T2-括号树" class="headerlink" title="Day1 T2 括号树"></a>Day1 T2 括号树</h1><h3 id="前置知识-dfs-dp"><a href="#前置知识-dfs-dp" class="headerlink" title="前置知识: dfs, dp"></a>前置知识: dfs, dp</h3><p>发现dfs的过程中的括号序列是从1到u的最长序列<br>u的合法字串是父亲fa的合法字串加上以u结尾的所有合法字串<br>如果u是$($，那么待匹配的$($多了一个, 记录上一个$($位置<br>如果u是$)$, 那么如果有待匹配的$($则匹配成功, 同时与此次匹配的$($之前所有的$()()$的左括号构成合法匹配<br>如果没有待匹配的$($则匹配失败，同时之前所有的$()()$变成了$()())$, 不能与之后的$)$匹配了<br>d[]表示合法字串数，dp[]表示之前$(…)(…)$的数量, mo表示上一个能匹配的$($位置</p>
<h3 id="code-1"><a href="#code-1" class="headerlink" title="code:"></a>code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">nc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">100000</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, <span class="number">100000</span>, <span class="built_in">stdin</span>), p1 == p2) ? EOF : *p1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">char</span> ch = nc();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">'('</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">')'</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        ch = nc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = nc();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">501000</span>;</span><br><span class="line"><span class="keyword">int</span> n, v[N], f[N], h[N], nxt[N], cnt, to[N], dp[N], m[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans, d[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> num, <span class="keyword">int</span> mo)</span> </span>&#123;</span><br><span class="line">    m[u] = mo;</span><br><span class="line">    d[u] = d[f[u]];</span><br><span class="line">    <span class="keyword">if</span>(v[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num) &#123;</span><br><span class="line">            d[u]++;</span><br><span class="line">            d[u] += dp[mo];</span><br><span class="line">            dp[u] = dp[mo] + <span class="number">1</span>;</span><br><span class="line">            mo = m[mo];</span><br><span class="line">            num--;</span><br><span class="line">        &#125; <span class="keyword">else</span> dp[u] = <span class="number">0</span>, mo = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">if</span>(mo == f[u]) dp[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> dp[u] = dp[f[u]];</span><br><span class="line">        mo = u;</span><br><span class="line">    &#125;</span><br><span class="line">    ans ^= u * d[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[u]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = to[i];</span><br><span class="line">        dfs(v, num, mo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    ++cnt; nxt[cnt] = h[u]; h[u] = cnt; to[cnt] = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) v[i] = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) f[i] = read(), add_edge(f[i], i);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Day1-T3-树上的数"><a href="#Day1-T3-树上的数" class="headerlink" title="Day1 T3 树上的数"></a>Day1 T3 树上的数</h1><h3 id="前置知识-贪心-链表-dfs优化枚举"><a href="#前置知识-贪心-链表-dfs优化枚举" class="headerlink" title="前置知识: 贪心, 链表, dfs优化枚举"></a>前置知识: 贪心, 链表, dfs优化枚举</h3><p><a href="https://www.zhihu.com/question/351347604/answer/896344216" target="_blank" rel="noopener">来自出题人的良心题解</a><br>就是贪心每次动权值最小的, 给它找到一个可行的编号最小的<br>对每个点用一个链表维护删边顺序, 来判断是否可行<br>我们发现如果cnt从$2$开始出边和入边编号为差1<br>用大常数s和t代表起始和终止, 则每个点的链表是s -&gt; 边1 -&gt; 边2 -&gt; … -&gt; t<br>用一次dfs找到可以到达的最小值<br>再用一次dfs维护链表<br>代码有详细注释</p>
<h3 id="code-2"><a href="#code-2" class="headerlink" title="code:"></a>code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> s = <span class="number">4100</span>; <span class="comment">// 用 s + 编号u 代表u的起始</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> t = <span class="number">6100</span>; <span class="comment">// 用 t + 编号u 代表u的终止</span></span><br><span class="line"><span class="keyword">int</span> T, n, p[N], nxt[N&lt;&lt;<span class="number">1</span>], h[N], to[N&lt;&lt;<span class="number">1</span>], cnt;</span><br><span class="line"><span class="keyword">int</span> ne[N&lt;&lt;<span class="number">1</span>], la[N&lt;&lt;<span class="number">1</span>], min_num;</span><br><span class="line"><span class="keyword">int</span> f[N&lt;&lt;<span class="number">1</span>], siz[N&lt;&lt;<span class="number">1</span>], in[N]; <span class="comment">// siz[]维护删了几条边 in[]维护共有几条边</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">nc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">100000</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, <span class="number">100000</span>, <span class="built_in">stdin</span>), p1 == p2) ? EOF : *p1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">char</span> ch = nc();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>) ch = nc();</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = nc();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    ++cnt; nxt[cnt] = h[u]; h[u] = cnt; to[cnt] = v; siz[cnt] = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="comment">// 如果是边 siz为1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[x] == x ? x : f[x] = find(f[x]);</span><br><span class="line">&#125; <span class="comment">// 用并查集维护链表是否成环</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(find(a) == find(b)) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 成环了不行</span></span><br><span class="line">    <span class="keyword">if</span>(ne[a] || la[b]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// a有后继或者b有前驱不行</span></span><br><span class="line">    <span class="keyword">int</span> fa = find(a), fb = find(b), fs = find(s+u), ft = find(t+u);</span><br><span class="line">    <span class="keyword">if</span>(fa == fs &amp;&amp; fb == ft)</span><br><span class="line">        <span class="keyword">if</span>(siz[fa] + siz[fb] &lt; in[u]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 若链表s与t相连, 只有边全部删完可以</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="comment">// 判断从u的a边向u的b边连链表是否可行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    ne[a] = b; </span><br><span class="line">    la[b] = a;</span><br><span class="line">    <span class="keyword">int</span> fa = find(a), fb = find(b);</span><br><span class="line">    f[fa] = fb;</span><br><span class="line">    siz[fb] += siz[fa];</span><br><span class="line">&#125; <span class="comment">// 连接a, b 维护并查集，删边数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_find</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> edge)</span> </span>&#123; <span class="comment">// 在u点, 从edge边进入的</span></span><br><span class="line">    <span class="keyword">if</span>(check(edge, t + u, u))</span><br><span class="line">        min_num = min(min_num, u); <span class="comment">// 看是否能从这个点结束</span></span><br><span class="line">    <span class="keyword">if</span>(ne[edge]) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = ne[edge];</span><br><span class="line">        <span class="keyword">int</span> v = to[i];</span><br><span class="line">        dfs_find(v, i ^ <span class="number">1</span>); <span class="comment">// 这条边有后继, 只能走后继边</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">int</span> i = h[u]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == edge) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> v = to[i];</span><br><span class="line">        <span class="keyword">if</span>(check(edge, i, u))</span><br><span class="line">            dfs_find(v, i ^ <span class="number">1</span>); <span class="comment">// 没有后继, 找一个做后继不冲突的边离开</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 在链表不发生冲突的情况下找到最小的编号</span></span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_change</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> edge)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == min_num) &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        Link(edge, t+u);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 找到终止点，回溯维护链表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ne[edge]) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = ne[edge];</span><br><span class="line">        <span class="keyword">int</span> v = to[i];</span><br><span class="line">        dfs_change(v, i ^ <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">int</span> i = h[u]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == edge) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> v = to[i];</span><br><span class="line">        <span class="keyword">if</span>(check(edge, i, u)) &#123;</span><br><span class="line">            dfs_change(v, i ^ <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                Link(edge, i);</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 维护链表</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 找到终止点并回溯更改</span></span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cnt = <span class="number">1</span>; <span class="comment">// cnt初始化为1, 从2开始编号，边与反向边^=1</span></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">memset</span>(ne, <span class="number">0</span>, <span class="keyword">sizeof</span>(ne));</span><br><span class="line">    <span class="built_in">memset</span>(la, <span class="number">0</span>, <span class="keyword">sizeof</span>(la));</span><br><span class="line">    <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="keyword">sizeof</span>(in));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N*<span class="number">2</span>; i++) f[i] = i, siz[i] = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T = read();</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        init();</span><br><span class="line">        n = read();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = read();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = read(), y = read();</span><br><span class="line">            add_edge(x, y);</span><br><span class="line">            add_edge(y, x);</span><br><span class="line">            in[x]++; in[y]++; <span class="comment">// 维护有多少条边</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="comment">// 贪心</span></span><br><span class="line">            min_num = n + <span class="number">1</span>;</span><br><span class="line">            dfs_find(p[i], s + p[i]); <span class="comment">// 从p[i]起始</span></span><br><span class="line">            ans[i] = min_num; <span class="comment">// 直接记录到达点即可，不用模拟删边</span></span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            dfs_change(p[i], s + p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Day2-T1"><a href="#Day2-T1" class="headerlink" title="Day2 T1"></a>Day2 T1</h1><h3 id="前置知识-dp-组合数学-容斥"><a href="#前置知识-dp-组合数学-容斥" class="headerlink" title="前置知识: dp, 组合数学, 容斥"></a>前置知识: dp, 组合数学, 容斥</h3><p>只满足条件2, 方案数为$\sum_{i=1}^n sum[i]+1$<br>$sum[i]+1$ 为所有可能做出的菜和不做菜的情况数<br>满足条件1, 方案数-1，全部不做<br>满足条件3, 只有1种菜可能超过一半，枚举这个主食材，用dp求出所有不合法方案数<br>$dp[i][j]$表示前i种烹饪法，主菜比其他菜总和多j个多情况<br>注意j可能为负，同时加上一个常数即可</p>
<h3 id="code-3"><a href="#code-3" class="headerlink" title="code:"></a>code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N][M];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Ans = <span class="number">1</span>, sum[N], dp[N][N+N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]), sum[i] += a[i][j], sum[i] %= mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        Ans *= (sum[i]+<span class="number">1</span>), Ans %= mod; --Ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= m; x++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>+N] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = -i; j &lt;= i; j++) &#123;</span><br><span class="line">                dp[i][j+N] = dp[i<span class="number">-1</span>][j+N]; <span class="comment">// 不做菜</span></span><br><span class="line">                dp[i][j+N] += dp[i<span class="number">-1</span>][j<span class="number">-1</span>+N] * a[i][x]; dp[i][j+N] %= mod; <span class="comment">// 用主食材做菜</span></span><br><span class="line">                dp[i][j+N] += dp[i<span class="number">-1</span>][j+<span class="number">1</span>+N] * (sum[i] - a[i][x]); dp[i][j+N] %= mod; <span class="comment">// 用其他食材做菜</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">                Ans += (mod - dp[n][k+N] % mod), Ans %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Day2-T2"><a href="#Day2-T2" class="headerlink" title="Day2 T2"></a>Day2 T2</h1><h3 id="前置知识-dp-单调队列-贪心-高精度"><a href="#前置知识-dp-单调队列-贪心-高精度" class="headerlink" title="前置知识: dp, 单调队列, 贪心, 高精度"></a>前置知识: dp, 单调队列, 贪心, 高精度</h3><p>很容易想到n方的dp，考虑优化这个dp<br>贪心:最后一个划分组最小的划分方式最优<br>证明:考虑最后一组和倒数第二组中间的数, 它只能被划分到最后一组或倒数第二组l, 设这个数为v, 倒数第二组为x, 最后一组为y<br>则划分到上一组为$( v + x ) * ( v + x ) + y * y$ $=$ $v * v + x * x + y * y + 2 * v * x$<br>划分到下一组为$ x * x + ( v + y ) * ( v + y )$ $=$ $v * v + x * x + y * y + 2 * v * y$<br>两者只差$( x - y ) * 2 * v$<br>由定义知 $x &lt;= y$ 所以划分到上一组一定比下一组优<br>于是用单调队列优化即可 $a[i] - a[j] &gt;= p[j]$ -&gt; $a[i] &gt;= p[j] + a[j]$</p>
<h3 id="code-4"><a href="#code-4" class="headerlink" title="code:"></a>code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">nc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">100000</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, <span class="number">100000</span>, <span class="built_in">stdin</span>), p1 == p2) ? EOF : *p1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">char</span> ch = nc();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>) ch = nc();</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = nc();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(__int128 x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">9</span>) print(x / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, type, x, y, z, b[N], m, P[M], l[M], r[M], g[N];</span><br><span class="line"><span class="keyword">int</span> q[N], head, tail;</span><br><span class="line">ll a[N], p[N];</span><br><span class="line">__int128 ans;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(); type = read();</span><br><span class="line">    <span class="keyword">if</span>(type == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x = read(); y = read(); z = read(); b[<span class="number">1</span>] = read(); b[<span class="number">2</span>] = read(); m = read();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) b[i] = (<span class="number">1l</span>l * x * b[i<span class="number">-1</span>] + <span class="number">1l</span>l * y * b[i<span class="number">-2</span>] + z) % mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            P[i] = read(); l[i] = read(); r[i] = read();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &gt; P[j]) j++;</span><br><span class="line">            a[i] = b[i] % (r[j] - l[j] + <span class="number">1</span>) + l[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] += a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(head &lt; tail &amp;&amp; a[i] - a[q[head+<span class="number">1</span>]] &gt;= p[q[head+<span class="number">1</span>]]) head++;</span><br><span class="line">        <span class="keyword">int</span> j = q[head];</span><br><span class="line">        p[i] = a[i] - a[j];</span><br><span class="line">        g[i] = j;</span><br><span class="line">        <span class="keyword">while</span>(head &lt; tail &amp;&amp; -p[q[tail]] + p[i] &lt;=  a[q[tail]] - a[i]) tail--;</span><br><span class="line">        q[++tail] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; i = g[i]) ans = ans + (__int128)p[i] * p[i];</span><br><span class="line">    print(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Day2-T3"><a href="#Day2-T3" class="headerlink" title="Day2 T3"></a>Day2 T3</h1><h3 id="前置知识-倍增-树型dp-树链剖分-dfs优化枚举"><a href="#前置知识-倍增-树型dp-树链剖分-dfs优化枚举" class="headerlink" title="前置知识: 倍增, 树型dp, 树链剖分, dfs优化枚举"></a>前置知识: 倍增, 树型dp, 树链剖分, dfs优化枚举</h3><p>树的重心只可能在其根所在重链上<br>通过倍增找出可能为重心的点, 检查它和它的父亲和重儿子是否为重心即可<br>倍增$p[u][i]$为向u的重儿子走$2^i$步, 条件为节点上边的点数小于总数/2<br>dfs求出重儿子, 次重儿子, 子树大小<br>solve以dfs的顺序换根，维护新的重儿子, 树大小, p数组(画图理解)<br>注意回溯<br>复杂度O(nlogn)</p>
<h3 id="code-5"><a href="#code-5" class="headerlink" title="code:"></a>code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">nc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">100000</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, <span class="number">100000</span>, <span class="built_in">stdin</span>), p1 == p2) ? EOF : *p1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">char</span> ch = nc();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>) ch = nc();</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = nc();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> siz[N], son[N], nxt[N&lt;&lt;<span class="number">1</span>], to[N&lt;&lt;<span class="number">1</span>], h[N], cnt, T, n, p[N][<span class="number">18</span>], son2[N], son3[N], siz2[N], f[N], pr[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    ++cnt; nxt[cnt] = h[u]; h[u] = cnt; to[cnt] = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    siz[u] = <span class="number">1</span>; pr[u] = fa; f[u] = fa;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[u]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = to[i];</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v, u);</span><br><span class="line">        siz[u] += siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[son[u]] &lt; siz[v]) son2[u] = son[u], son[u] = v;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(siz[son2[u]] &lt; siz[v]) son2[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    p[u][<span class="number">0</span>] = son[u];</span><br><span class="line">    son3[u] = son[u];</span><br><span class="line">    siz2[u] = siz[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">17</span>; i++) p[u][i] = p[p[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(max(siz2[son3[u]], num - siz2[u]) &lt;= num / <span class="number">2</span>) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[u]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = to[i];</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        siz2[u] = siz[<span class="number">1</span>] - siz[v]; f[u] = f[v] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(v == son[u]) son3[u] = son2[u];</span><br><span class="line">        <span class="keyword">else</span> son3[u] = son[u];</span><br><span class="line">        <span class="keyword">if</span>(siz2[son3[u]] &lt; siz2[fa]) son3[u] = fa;</span><br><span class="line">        p[u][<span class="number">0</span>] = son3[u];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">17</span>; j++) p[u][j] = p[p[u][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> now = u;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">17</span>; j &gt;= <span class="number">0</span>; j--) <span class="keyword">if</span>(siz2[u] - siz2[p[now][j]] &lt;= siz2[u] / <span class="number">2</span>) now = p[now][j];</span><br><span class="line">        ans += check(son3[now], siz2[u]) + check(now, siz2[u]) + check(f[now], siz2[u]);</span><br><span class="line">        now = v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">17</span>; j &gt;= <span class="number">0</span>; j--) <span class="keyword">if</span>(siz2[v] - siz2[p[now][j]] &lt;= siz2[v] / <span class="number">2</span>) now = p[now][j];</span><br><span class="line">        ans += check(son3[now], siz2[v]) + check(now, siz2[v]) + check(f[now], siz2[v]);</span><br><span class="line">        f[u] = v;</span><br><span class="line">        solve(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    f[u] = pr[u]; son3[u] = son[u]; siz2[u] = siz[u];</span><br><span class="line">    p[u][<span class="number">0</span>] = son[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">17</span>; i++) p[u][i] = p[p[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">memset</span>(son, <span class="number">0</span>, <span class="keyword">sizeof</span>(son));</span><br><span class="line">    <span class="built_in">memset</span>(son2, <span class="number">0</span>, <span class="keyword">sizeof</span>(son2));</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T = read();</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        init();</span><br><span class="line">        n = read();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = read(), y = read();</span><br><span class="line">            add_edge(x, y);</span><br><span class="line">            add_edge(y, x);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        solve(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div class="tags"><a href="/tags/solution/">solution</a></div><div class="post-nav"><a class="pre" href="/2019/11/24/hello-world/">Hello World</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.1"><script src="/js/gitment.browser.js?v=0.0.1"></script><script>var gitment = new Gitment({
  id: window.location.pathname.substring(1,window.location.pathname.length),
  owner: 'zty111',
  repo: 'https://github.com/zty111/blogcomments',
  oauth: {
    client_id: 'ab8c7809b9d21a5036bd',
    client_secret: 'e63733d8801e64b4b0ffd505d588e140c4390a3d',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://ztyblog.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/solution/" style="font-size: 15px;">solution</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/11/24/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/24/csps2019题解/">csps2019题解</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://tony031218.github.io" title="吉林一中whx" target="_blank">吉林一中whx</a><ul></ul><a href="www.ztyblog.com" title="..." target="_blank">...</a><ul></ul><a href="www.ztyblog.com" title="..." target="_blank">...</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Blog of zty.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.1" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.1"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.1"></script></div></body></html>