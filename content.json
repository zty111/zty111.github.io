{"meta":{"title":"Blog of zty","subtitle":"focus on coding","description":"zty的博客，主要更新oi相关，欢迎大家来玩。","author":"zty","url":"http://ztyblog.com","root":"/"},"pages":[{"title":"About me","date":"2019-09-30T23:45:58.000Z","updated":"2019-09-30T23:45:58.853Z","comments":true,"path":"about/me.html","permalink":"http://ztyblog.com/about/me.html","excerpt":"","text":""},{"title":"board","date":"2019-09-30T11:36:31.000Z","updated":"2019-09-30T11:36:31.932Z","comments":true,"path":"board/index.html","permalink":"http://ztyblog.com/board/index.html","excerpt":"","text":""},{"title":"solution","date":"2019-11-24T14:06:13.000Z","updated":"2019-11-24T14:07:22.369Z","comments":true,"path":"solution/index.html","permalink":"http://ztyblog.com/solution/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2019-11-24T15:40:11.431Z","updated":"2019-11-24T15:40:11.432Z","comments":true,"path":"2019/11/24/hello-world/","link":"","permalink":"http://ztyblog.com/2019/11/24/hello-world/","excerpt":"","text":"建于2019.9.30使用hexo","categories":[],"tags":[]},{"title":"csps2019题解","slug":"csps2019题解","date":"2019-11-24T14:06:27.000Z","updated":"2019-11-25T15:34:50.905Z","comments":true,"path":"2019/11/24/csps2019题解/","link":"","permalink":"http://ztyblog.com/2019/11/24/csps2019题解/","excerpt":"","text":"Day1 T1 格雷码前置知识: 语法, 模拟$n$位格雷码有$n^2$个 , 分成第$k$个在左右哪边讨论即可注意格雷码构造的时候有翻转操作最大的坑点是 unsigned long long, 1ull, k不能加1 code:12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;int i, a[100];void solve(int n, ull k) &#123; if(n == 0) return; ull len = 1ull &lt;&lt; (n-1); if(k &gt;= len) a[++i] = 1, solve(n - 1, len - k - 1ull + len); else a[++i] = 0, solve(n - 1, k);&#125;int main() &#123; ull k; int n; scanf(\"%d %llu\", &amp;n, &amp;k); solve(n, k); for(int j = 1; j &lt;= i; j++) printf(\"%d\", a[j]); printf(\"\\n\"); return 0;&#125; Day1 T2 括号树前置知识: dfs, dp发现dfs的过程中的括号序列是从1到u的最长序列u的合法字串是父亲fa的合法字串加上以u结尾的所有合法字串如果u是$($，那么待匹配的$($多了一个, 记录上一个$($位置如果u是$)$, 那么如果有待匹配的$($则匹配成功, 同时与此次匹配的$($之前所有的$()()$的左括号构成合法匹配如果没有待匹配的$($则匹配失败，同时之前所有的$()()$变成了$()())$, 不能与之后的$)$匹配了d[]表示合法字串数，dp[]表示之前$(…)(…)$的数量, mo表示上一个能匹配的$($位置 code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;inline char nc() &#123; static char buf[100000], *p1 = buf, *p2 = buf; return p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;&#125;inline int read() &#123; int x = 0; char ch = nc(); while(ch &lt; '0' || ch &gt; '9') &#123; if(ch == '(') return 0; else if(ch == ')') return 1; ch = nc(); &#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - 48, ch = nc(); return x;&#125;const int N = 501000;int n, v[N], f[N], h[N], nxt[N], cnt, to[N], dp[N], m[N];long long ans, d[N];void dfs(int u, int num, int mo) &#123; m[u] = mo; d[u] = d[f[u]]; if(v[u]) &#123; if(num) &#123; d[u]++; d[u] += dp[mo]; dp[u] = dp[mo] + 1; mo = m[mo]; num--; &#125; else dp[u] = 0, mo = 0; &#125; else &#123; num++; if(mo == f[u]) dp[u] = 0; else dp[u] = dp[f[u]]; mo = u; &#125; ans ^= u * d[u]; for(int i = h[u]; i; i = nxt[i]) &#123; int v = to[i]; dfs(v, num, mo); &#125;&#125;inline void add_edge(int u, int v) &#123; ++cnt; nxt[cnt] = h[u]; h[u] = cnt; to[cnt] = v;&#125;int main() &#123; n = read(); for(int i = 1; i &lt;= n; i++) v[i] = read(); for(int i = 2; i &lt;= n; i++) f[i] = read(), add_edge(f[i], i); dfs(1, 0, 0); printf(\"%lld\\n\", ans); return 0;&#125; Day1 T3 树上的数前置知识: 贪心, 链表, dfs优化枚举来自出题人的良心题解就是贪心每次动权值最小的, 给它找到一个可行的编号最小的对每个点用一个链表维护删边顺序, 来判断是否可行我们发现如果cnt从$2$开始出边和入边编号为差1用大常数s和t代表起始和终止, 则每个点的链表是s -&gt; 边1 -&gt; 边2 -&gt; … -&gt; t用一次dfs找到可以到达的最小值再用一次dfs维护链表代码有详细注释 code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 4100;const int s = 4100; // 用 s + 编号u 代表u的起始const int t = 6100; // 用 t + 编号u 代表u的终止int T, n, p[N], nxt[N&lt;&lt;1], h[N], to[N&lt;&lt;1], cnt;int ne[N&lt;&lt;1], la[N&lt;&lt;1], min_num;int f[N&lt;&lt;1], siz[N&lt;&lt;1], in[N]; // siz[]维护删了几条边 in[]维护共有几条边inline char nc() &#123; static char buf[100000], *p1 = buf, *p2 = buf; return p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;&#125;inline int read() &#123; int x = 0; char ch = nc(); while(ch &lt; '0' || ch &gt; '9') ch = nc(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - 48, ch = nc(); return x;&#125;inline void add_edge(int u, int v) &#123; ++cnt; nxt[cnt] = h[u]; h[u] = cnt; to[cnt] = v; siz[cnt] = 1;&#125; // 如果是边 siz为1int find(int x) &#123; return f[x] == x ? x : f[x] = find(f[x]);&#125; // 用并查集维护链表是否成环bool check(int a, int b, int u) &#123; if(find(a) == find(b)) return false; // 成环了不行 if(ne[a] || la[b]) return false; // a有后继或者b有前驱不行 int fa = find(a), fb = find(b), fs = find(s+u), ft = find(t+u); if(fa == fs &amp;&amp; fb == ft) if(siz[fa] + siz[fb] &lt; in[u]) return false; // 若链表s与t相连, 只有边全部删完可以 return true;&#125; // 判断从u的a边向u的b边连链表是否可行void Link(int a, int b) &#123; ne[a] = b; la[b] = a; int fa = find(a), fb = find(b); f[fa] = fb; siz[fb] += siz[fa];&#125; // 连接a, b 维护并查集，删边数void dfs_find(int u, int edge) &#123; // 在u点, 从edge边进入的 if(check(edge, t + u, u)) min_num = min(min_num, u); // 看是否能从这个点结束 if(ne[edge]) &#123; int i = ne[edge]; int v = to[i]; dfs_find(v, i ^ 1); // 这条边有后继, 只能走后继边 &#125; else for(int i = h[u]; i; i = nxt[i]) &#123; if(i == edge) continue; int v = to[i]; if(check(edge, i, u)) dfs_find(v, i ^ 1); // 没有后继, 找一个做后继不冲突的边离开 &#125;&#125; // 在链表不发生冲突的情况下找到最小的编号bool flag;void dfs_change(int u, int edge) &#123; if(u == min_num) &#123; flag = true; Link(edge, t+u); return; // 找到终止点，回溯维护链表 &#125; if(ne[edge]) &#123; int i = ne[edge]; int v = to[i]; dfs_change(v, i ^ 1); &#125; else for(int i = h[u]; i; i = nxt[i]) &#123; if(i == edge) continue; int v = to[i]; if(check(edge, i, u)) &#123; dfs_change(v, i ^ 1); if(flag) &#123; Link(edge, i); return; // 维护链表 &#125; &#125; &#125;&#125; // 找到终止点并回溯更改int ans[N];void init() &#123; cnt = 1; // cnt初始化为1, 从2开始编号，边与反向边^=1 memset(h, 0, sizeof(h)); memset(ne, 0, sizeof(ne)); memset(la, 0, sizeof(la)); memset(in, 0, sizeof(in)); for(int i = 1; i &lt; N*2; i++) f[i] = i, siz[i] = 0;&#125; // 初始化int main() &#123; T = read(); while(T--) &#123; init(); n = read(); for(int i = 1; i &lt;= n; i++) p[i] = read(); for(int i = 1; i &lt; n; i++) &#123; int x = read(), y = read(); add_edge(x, y); add_edge(y, x); in[x]++; in[y]++; // 维护有多少条边 &#125; for(int i = 1; i &lt;= n; i++) &#123; // 贪心 min_num = n + 1; dfs_find(p[i], s + p[i]); // 从p[i]起始 ans[i] = min_num; // 直接记录到达点即可，不用模拟删边 flag = false; dfs_change(p[i], s + p[i]); &#125; for(int i = 1; i &lt;= n; i++) printf(\"%d \", ans[i]); printf(\"\\n\"); &#125; return 0;&#125; Day2 T1前置知识: dp, 组合数学, 容斥只满足条件2, 方案数为$\\sum_{i=1}^n sum[i]+1$$sum[i]+1$ 为所有可能做出的菜和不做菜的情况数满足条件1, 方案数-1，全部不做满足条件3, 只有1种菜可能超过一半，枚举这个主食材，用dp求出所有不合法方案数$dp[i][j]$表示前i种烹饪法，主菜比其他菜总和多j个多情况注意j可能为负，同时加上一个常数即可 code:12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 110;const int M = 2100;const int mod = 998244353;int n, m, a[N][M];long long Ans = 1, sum[N], dp[N][N+N];int main() &#123; scanf(\"%d %d\", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) scanf(\"%d\", &amp;a[i][j]), sum[i] += a[i][j], sum[i] %= mod; for(int i = 1; i &lt;= n; i++) Ans *= (sum[i]+1), Ans %= mod; --Ans; for(int x = 1; x &lt;= m; x++) &#123; dp[0][0+N] = 1; for(int i = 1; i &lt;= n; i++) for(int j = -i; j &lt;= i; j++) &#123; dp[i][j+N] = dp[i-1][j+N]; // 不做菜 dp[i][j+N] += dp[i-1][j-1+N] * a[i][x]; dp[i][j+N] %= mod; // 用主食材做菜 dp[i][j+N] += dp[i-1][j+1+N] * (sum[i] - a[i][x]); dp[i][j+N] %= mod; // 用其他食材做菜 &#125; for(int k = 1; k &lt;= n; k++) Ans += (mod - dp[n][k+N] % mod), Ans %= mod; &#125; printf(\"%lld\\n\", Ans); return 0;&#125; Day2 T2前置知识: dp, 单调队列, 贪心, 高精度很容易想到n方的dp，考虑优化这个dp贪心:最后一个划分组最小的划分方式最优证明:考虑最后一组和倒数第二组中间的数, 它只能被划分到最后一组或倒数第二组l, 设这个数为v, 倒数第二组为x, 最后一组为y则划分到上一组为$( v + x ) * ( v + x ) + y * y$ $=$ $v * v + x * x + y * y + 2 * v * x$划分到下一组为$ x * x + ( v + y ) * ( v + y )$ $=$ $v * v + x * x + y * y + 2 * v * y$两者只差$( x - y ) * 2 * v$由定义知 $x &lt;= y$ 所以划分到上一组一定比下一组优于是用单调队列优化即可 $a[i] - a[j] &gt;= p[j]$ -&gt; $a[i] &gt;= p[j] + a[j]$ code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;inline char nc() &#123; static char buf[100000], *p1 = buf, *p2 = buf; return p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;&#125;inline int read() &#123; int x = 0; char ch = nc(); while(ch &lt; '0' || ch &gt; '9') ch = nc(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - 48, ch = nc(); return x;&#125;typedef long long ll;void print(__int128 x) &#123; if(x &gt; 9) print(x / 10); putchar(x % 10 + '0');&#125;const int N = 4e7+10;const int M = 1e5+10;int n, type, x, y, z, b[N], m, P[M], l[M], r[M], g[N];int q[N], head, tail;ll a[N], p[N];__int128 ans;const int mod = 1&lt;&lt;30;int main() &#123; n = read(); type = read(); if(type == 0) &#123; for(int i = 1; i &lt;= n; i++) a[i] = read(); &#125; else &#123; x = read(); y = read(); z = read(); b[1] = read(); b[2] = read(); m = read(); for(int i = 3; i &lt;= n; i++) b[i] = (1ll * x * b[i-1] + 1ll * y * b[i-2] + z) % mod; for(int i = 1; i &lt;= m; i++) &#123; P[i] = read(); l[i] = read(); r[i] = read(); &#125; for(int i = 1, j = 1; i &lt;= n; i++) &#123; while(i &gt; P[j]) j++; a[i] = b[i] % (r[j] - l[j] + 1) + l[j]; &#125; &#125; for(int i = 1; i &lt;= n; i++) a[i] += a[i-1]; for(int i = 1; i &lt;= n; i++) &#123; while(head &lt; tail &amp;&amp; a[i] - a[q[head+1]] &gt;= p[q[head+1]]) head++; int j = q[head]; p[i] = a[i] - a[j]; g[i] = j; while(head &lt; tail &amp;&amp; -p[q[tail]] + p[i] &lt;= a[q[tail]] - a[i]) tail--; q[++tail] = i; &#125; for(int i = n; i; i = g[i]) ans = ans + (__int128)p[i] * p[i]; print(ans); return 0;&#125; Day2 T3前置知识: 倍增, 树型dp, 树链剖分, dfs优化枚举树的重心只可能在其根所在重链上通过倍增找出可能为重心的点, 检查它和它的父亲和重儿子是否为重心即可倍增$p[u][i]$为向u的重儿子走$2^i$步, 条件为节点上边的点数小于总数/2dfs求出重儿子, 次重儿子, 子树大小solve以dfs的顺序换根，维护新的重儿子, 树大小, p数组(画图理解)注意回溯复杂度O(nlogn) code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;inline char nc() &#123; static char buf[100000], *p1 = buf, *p2 = buf; return p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;&#125;inline int read() &#123; int x = 0; char ch = nc(); while(ch &lt; '0' || ch &gt; '9') ch = nc(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - 48, ch = nc(); return x;&#125;const int N = 3e5+10;int siz[N], son[N], nxt[N&lt;&lt;1], to[N&lt;&lt;1], h[N], cnt, T, n, p[N][18], son2[N], son3[N], siz2[N], f[N], pr[N];long long ans;inline void add_edge(int u, int v) &#123; ++cnt; nxt[cnt] = h[u]; h[u] = cnt; to[cnt] = v;&#125;void dfs(int u, int fa) &#123; siz[u] = 1; pr[u] = fa; f[u] = fa; for(int i = h[u]; i; i = nxt[i]) &#123; int v = to[i]; if(v == fa) continue; dfs(v, u); siz[u] += siz[v]; if(siz[son[u]] &lt; siz[v]) son2[u] = son[u], son[u] = v; else if(siz[son2[u]] &lt; siz[v]) son2[u] = v; &#125; p[u][0] = son[u]; son3[u] = son[u]; siz2[u] = siz[u]; for(int i = 1; i &lt;= 17; i++) p[u][i] = p[p[u][i-1]][i-1];&#125;int check(int u, int num) &#123; if(max(siz2[son3[u]], num - siz2[u]) &lt;= num / 2) return u; else return 0;&#125;void solve(int u, int fa) &#123; for(int i = h[u]; i; i = nxt[i]) &#123; int v = to[i]; if(v == fa) continue; siz2[u] = siz[1] - siz[v]; f[u] = f[v] = 0; if(v == son[u]) son3[u] = son2[u]; else son3[u] = son[u]; if(siz2[son3[u]] &lt; siz2[fa]) son3[u] = fa; p[u][0] = son3[u]; for(int j = 1; j &lt;= 17; j++) p[u][j] = p[p[u][j-1]][j-1]; int now = u; for(int j = 17; j &gt;= 0; j--) if(siz2[u] - siz2[p[now][j]] &lt;= siz2[u] / 2) now = p[now][j]; ans += check(son3[now], siz2[u]) + check(now, siz2[u]) + check(f[now], siz2[u]); now = v; for(int j = 17; j &gt;= 0; j--) if(siz2[v] - siz2[p[now][j]] &lt;= siz2[v] / 2) now = p[now][j]; ans += check(son3[now], siz2[v]) + check(now, siz2[v]) + check(f[now], siz2[v]); f[u] = v; solve(v, u); &#125; f[u] = pr[u]; son3[u] = son[u]; siz2[u] = siz[u]; p[u][0] = son[u]; for(int i = 1; i &lt;= 17; i++) p[u][i] = p[p[u][i-1]][i-1];&#125;void init() &#123; cnt = 0; memset(h, 0, sizeof(h)); memset(son, 0, sizeof(son)); memset(son2, 0, sizeof(son2)); ans = 0;&#125;int main() &#123; T = read(); while(T--) &#123; init(); n = read(); for(int i = 1; i &lt; n; i++) &#123; int x = read(), y = read(); add_edge(x, y); add_edge(y, x); &#125; dfs(1, 0); solve(1, 0); printf(\"%lld\\n\", ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"solution","slug":"solution","permalink":"http://ztyblog.com/tags/solution/"}]}]}